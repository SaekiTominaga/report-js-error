var e,t,o,s=this&&this.__classPrivateFieldSet||function(e,t,o){if(!t.has(e))throw new TypeError("attempted to set private field on non-instance");return t.set(e,o),o},r=this&&this.__classPrivateFieldGet||function(e,t){if(!t.has(e))throw new TypeError("attempted to get private field on non-instance");return t.get(e)};export default class{constructor(r,n={}){e.set(this,void 0),t.set(this,void 0),o.set(this,void 0),s(this,e,r),s(this,t,n),s(this,o,this._errorEvent.bind(this))}init(){const e=navigator.userAgent,s=r(this,t).denyUAs;if(void 0!==s&&s.some((t=>t.test(e))))return void console.info("No JavaScript error report will be sent because the user agent match the deny list.");const n=r(this,t).allowUAs;void 0===n||n.some((t=>t.test(e)))?window.addEventListener("error",r(this,o),{passive:!0}):console.info("No JavaScript error report will be sent because the user agent does not match the allow list.")}async _errorEvent(o){const s=o.message,n=o.filename,i=o.lineno,a=o.colno;if(""===n)return void console.error("ErrorEvent.filename is empty");const l=r(this,t).denyFilenames;if(void 0!==l&&l.some((e=>e.test(n))))return void console.info("No JavaScript error report will be sent because the filename match the deny list.");const c=r(this,t).allowFilenames;if(void 0!==c&&!c.some((e=>e.test(n))))return void console.info("No JavaScript error report will be sent because the filename does not match the allow list.");switch(new URL(n).protocol){case"https:":case"http:":break;default:return void console.error("A JavaScript error has occurred in a non-HTTP protocol (This may be due to a browser extension).")}const h=new FormData;h.append("location",location.toString()),h.append("message",s),h.append("filename",n),h.append("lineno",String(i)),h.append("colno",String(a));const d=await fetch(r(this,e),{method:"POST",headers:r(this,t).fetchHeaders,body:new URLSearchParams([...h])});d.ok||console.error(`"${d.url}" is ${d.status} ${d.statusText}`)}}e=new WeakMap,t=new WeakMap,o=new WeakMap;
//# sourceMappingURL=ReportJSError.min.js.map